{"ast":null,"code":"import { conf } from '../config';\nimport { LoggerService } from './LoggerService';\nimport { HTTP_ERROR_CODE } from './HttpTypes';\nimport { catchError, map, retryWhen, switchMap, timeout } from 'rxjs/operators';\nimport Axios from 'axios-observable';\nimport StringUtils from './StringUtils';\nimport { throwError, TimeoutError, timer } from 'rxjs';\nconst HTTP_RETRY_INTERVAL = conf.httpRetryInterval;\nconst HTTP_RETRY_LIMIT = conf.httpRetryLimit;\nconst HTTP_REQUEST_TIMEOUT = conf.httpRequestTimeout;\nconst HTTP_REQUEST_TIMEOUT_RETRY_LIMIT = conf.httpRequestTimeoutRetryLimit;\nconst RES_TYPE = 'arraybuffer';\nconst logger = LoggerService.getLogger('HttpService');\nexport class HttpService {\n  static get(urlPath, requestOptions) {\n    return HttpService._request('get', urlPath, requestOptions);\n  }\n\n  static post(urlPath, requestOptions) {\n    return HttpService._request('post', urlPath, requestOptions);\n  }\n\n  static put(urlPath, requestOptions) {\n    return HttpService._request('put', urlPath, requestOptions);\n  }\n\n  static _request(method, urlPath, requestOptions) {\n    requestOptions = requestOptions || Object.freeze({});\n    const _requestOptions = requestOptions,\n          useMockApi = _requestOptions.useMockApi,\n          externalUrl = _requestOptions.externalUrl,\n          pathParams = _requestOptions.pathParams,\n          queryParams = _requestOptions.queryParams,\n          responseType = _requestOptions.responseType,\n          data = _requestOptions.data;\n    let _requestOptions2 = requestOptions,\n        httpRetryLimit = _requestOptions2.httpRetryLimit;\n    const mockApiBase = useMockApi ? conf.mockApiBase : '';\n    const url = externalUrl || HttpUtils.parseUrlWithParams(urlPath, pathParams, mockApiBase);\n\n    if ((method === 'put' || method === 'post') && !requestOptions.data) {\n      logger.warn(`data should be provided in the requestOptions for ${method} ${url}`);\n    }\n\n    if (method === 'post' && (httpRetryLimit === null || httpRetryLimit === undefined)) {\n      httpRetryLimit = 0;\n    }\n\n    const axiosOpts = {\n      method,\n      url: url,\n      data: data || null,\n      withCredentials: true,\n      responseType: responseType || RES_TYPE,\n      params: queryParams || null\n    };\n    axios.defaults.crossDomain = true;\n    return Axios.request(axiosOpts).pipe(timeout(requestOptions.httpTimeout || HTTP_REQUEST_TIMEOUT), retryWhen(errObs => {\n      return HttpUtils.timedRetryHandler(errObs, httpRetryLimit, url);\n    }), catchError(HttpUtils.errHandler), map(requestOptions.parser || HttpUtils.parseJson));\n  }\n\n}\nexport class HttpError {\n  constructor(code, message) {\n    this.code = code;\n    this.message = message;\n  }\n\n  toString() {\n    return `HttpError: ${this.code} ${this.message}`;\n  }\n\n}\nexport class HttpUtils {\n  static parseJson(res) {\n    if (!res || res.data === null || res.data === undefined) {\n      return null;\n    }\n\n    let responseText = '';\n\n    try {\n      responseText = Buffer.from(res.data, 'binary').toString();\n    } catch (e) {\n      logger.error('Failed reading response body from server, returning null.');\n      return null;\n    }\n\n    const url = HttpUtils.rebuildReqUrl(res);\n\n    if (responseText === '' || responseText === 'OK') {\n      logger.info(`${res.status} ${res.statusText}: ${url}`);\n      return null;\n    }\n\n    try {\n      logger.info(`${res.status} ${res.statusText}: ${url}`);\n      return JSON.parse(responseText);\n    } catch (e) {\n      const resTextObj = {\n        responseText: responseText\n      };\n      logger.warn(`${url}: Server returned text instead of JSON, using: ${JSON.stringify(resTextObj)}`);\n      return resTextObj;\n    }\n  }\n\n  // Axios leaves the query params out of the url, and this method recreates the full url.\n  static rebuildReqUrl(res) {\n    let url = res.config.url;\n\n    if (res.config.params) {\n      const params = res.config.params;\n      const paramKeys = Object.keys(params);\n\n      if (paramKeys.length > 0) {\n        try {\n          // build the query params back in\n          url = url + '?' + paramKeys.map(k => `${k}=${encodeURIComponent(params[k])}`).join('&');\n        } catch (e) {\n          logger.warn(`${url}: Failed to rebuild url string`);\n        }\n      }\n    }\n\n    return url;\n  }\n\n  static parseUrlWithParams(urlPath, params, apiBase) {\n    const base = apiBase || conf.api.base;\n\n    if (!params || Object.keys(params).length === 0) {\n      return base + urlPath;\n    }\n\n    const url = base + urlPath;\n    const colonParams = {};\n    Object.keys(params).forEach(key => {\n      colonParams[':' + key] = params[key];\n    });\n    return StringUtils.replaceMap(url, colonParams);\n  }\n\n  static timedRetryHandler(errObs, httpRetryLimit = HTTP_RETRY_LIMIT, url) {\n    if (httpRetryLimit === null || httpRetryLimit === undefined) {\n      httpRetryLimit = conf.httpRetryLimit;\n    }\n\n    let count = 0;\n    return errObs.pipe(switchMap(res => {\n      if (res instanceof TimeoutError && count < HTTP_REQUEST_TIMEOUT_RETRY_LIMIT) {\n        logger.debug('Retrying request after timeout to url \"' + url + '\".', 'Attempt ' + count + '.');\n        count += 1;\n        return timer(HTTP_RETRY_INTERVAL);\n      } else if (count >= httpRetryLimit || res.status === HTTP_ERROR_CODE.BAD_REQUEST || res.status === HTTP_ERROR_CODE.UNAUTHORIZED) {\n        return throwError(res);\n      } else {\n        logger.debug('Retrying request to url \"' + url + '\".', 'Attempt ' + count + '.');\n        count += 1;\n        return timer(HTTP_RETRY_INTERVAL);\n      }\n    }));\n  }\n\n  static errHandler(res) {\n    if (res instanceof TimeoutError) {\n      return throwError(new HttpError(408, res.message));\n    }\n\n    let code = 0,\n        message = '';\n\n    try {\n      code = res.response.status;\n      message = res.response.statusText;\n    } catch (err) {\n      logger.error('Error parsing server error message.');\n    }\n\n    const emptyMessage = !message || !message.toLowerCase() || message.toLowerCase().includes('ok');\n    const systemError = code === HTTP_ERROR_CODE.SYSTEM || !code;\n\n    if (emptyMessage || systemError) {\n      message = conf.defaultErrMessage;\n    }\n\n    logger.error('Failed request to url', res.config.url + '. Status', code, '. Message', message + '.');\n    return throwError(new HttpError(code, message));\n  }\n\n}","map":{"version":3,"sources":["C:/Git/personal/split-timer/src/helpers/HttpService.js"],"names":["conf","LoggerService","HTTP_ERROR_CODE","catchError","map","retryWhen","switchMap","timeout","Axios","StringUtils","throwError","TimeoutError","timer","HTTP_RETRY_INTERVAL","httpRetryInterval","HTTP_RETRY_LIMIT","httpRetryLimit","HTTP_REQUEST_TIMEOUT","httpRequestTimeout","HTTP_REQUEST_TIMEOUT_RETRY_LIMIT","httpRequestTimeoutRetryLimit","RES_TYPE","logger","getLogger","HttpService","get","urlPath","requestOptions","_request","post","put","method","Object","freeze","useMockApi","externalUrl","pathParams","queryParams","responseType","data","mockApiBase","url","HttpUtils","parseUrlWithParams","warn","undefined","axiosOpts","withCredentials","params","axios","defaults","crossDomain","request","pipe","httpTimeout","errObs","timedRetryHandler","errHandler","parser","parseJson","HttpError","constructor","code","message","toString","res","responseText","Buffer","from","e","error","rebuildReqUrl","info","status","statusText","JSON","parse","resTextObj","stringify","config","paramKeys","keys","length","k","encodeURIComponent","join","apiBase","base","api","colonParams","forEach","key","replaceMap","count","debug","BAD_REQUEST","UNAUTHORIZED","response","err","emptyMessage","toLowerCase","includes","systemError","SYSTEM","defaultErrMessage"],"mappings":"AACA,SAAQA,IAAR,QAAmB,WAAnB;AACA,SAAQC,aAAR,QAA4B,iBAA5B;AACA,SAAQC,eAAR,QAA8B,aAA9B;AACA,SAAQC,UAAR,EAAoBC,GAApB,EAAyBC,SAAzB,EAAoCC,SAApC,EAA+CC,OAA/C,QAA6D,gBAA7D;AACA,OAAOC,KAAP,MAAkB,kBAAlB;AACA,OAAOC,WAAP,MAAwB,eAAxB;AACA,SAAQC,UAAR,EAAoBC,YAApB,EAAkCC,KAAlC,QAA8C,MAA9C;AAEA,MAAMC,mBAAmB,GAAGb,IAAI,CAACc,iBAAjC;AACA,MAAMC,gBAAgB,GAAGf,IAAI,CAACgB,cAA9B;AACA,MAAMC,oBAAoB,GAAGjB,IAAI,CAACkB,kBAAlC;AACA,MAAMC,gCAAgC,GAAGnB,IAAI,CAACoB,4BAA9C;AACA,MAAMC,QAAQ,GAAG,aAAjB;AAEA,MAAMC,MAAM,GAAGrB,aAAa,CAACsB,SAAd,CAAwB,aAAxB,CAAf;AAEA,OAAO,MAAMC,WAAN,CAAkB;AAEvB,SAAOC,GAAP,CAAWC,OAAX,EAAoBC,cAApB,EAAoC;AACpC,WAAOH,WAAW,CAACI,QAAZ,CAAqB,KAArB,EAA4BF,OAA5B,EAAqCC,cAArC,CAAP;AACD;;AAED,SAAOE,IAAP,CAAYH,OAAZ,EAAqBC,cAArB,EAAqC;AACnC,WAAOH,WAAW,CAACI,QAAZ,CAAqB,MAArB,EAA6BF,OAA7B,EAAsCC,cAAtC,CAAP;AACD;;AAED,SAAOG,GAAP,CAAWJ,OAAX,EAAoBC,cAApB,EAAoC;AAClC,WAAOH,WAAW,CAACI,QAAZ,CAAqB,KAArB,EAA4BF,OAA5B,EAAqCC,cAArC,CAAP;AACD;;AAED,SAAOC,QAAP,CAAgBG,MAAhB,EAAwBL,OAAxB,EAAiCC,cAAjC,EAAiD;AAC/CA,IAAAA,cAAc,GAAGA,cAAc,IAAKK,MAAM,CAACC,MAAP,CAAc,EAAd,CAApC;AAD+C,4BAG8BN,cAH9B;AAAA,UAG1CO,UAH0C,mBAG1CA,UAH0C;AAAA,UAG9BC,WAH8B,mBAG9BA,WAH8B;AAAA,UAGjBC,UAHiB,mBAGjBA,UAHiB;AAAA,UAGLC,WAHK,mBAGLA,WAHK;AAAA,UAGQC,YAHR,mBAGQA,YAHR;AAAA,UAGsBC,IAHtB,mBAGsBA,IAHtB;AAAA,2BAI1BZ,cAJ0B;AAAA,QAI5CX,cAJ4C,oBAI5CA,cAJ4C;AAMjD,UAAMwB,WAAW,GAAGN,UAAU,GAAGlC,IAAI,CAACwC,WAAR,GAAsB,EAApD;AACA,UAAMC,GAAG,GAAGN,WAAW,IAAIO,SAAS,CAACC,kBAAV,CAA6BjB,OAA7B,EAAsCU,UAAtC,EAAkDI,WAAlD,CAA3B;;AAEA,QAAI,CAACT,MAAM,KAAK,KAAX,IAAoBA,MAAM,KAAK,MAAhC,KAA2C,CAACJ,cAAc,CAACY,IAA/D,EAAqE;AACnEjB,MAAAA,MAAM,CAACsB,IAAP,CAAa,qDAAoDb,MAAO,IAAGU,GAAI,EAA/E;AACD;;AAED,QAAIV,MAAM,KAAK,MAAX,KAAsBf,cAAc,KAAK,IAAnB,IAA2BA,cAAc,KAAK6B,SAApE,CAAJ,EAAoF;AAClF7B,MAAAA,cAAc,GAAG,CAAjB;AACD;;AAED,UAAM8B,SAAS,GAAG;AAChBf,MAAAA,MADgB;AAEhBU,MAAAA,GAAG,EAAEA,GAFW;AAGhBF,MAAAA,IAAI,EAAEA,IAAI,IAAI,IAHE;AAIhBQ,MAAAA,eAAe,EAAE,IAJD;AAKhBT,MAAAA,YAAY,EAAEA,YAAY,IAAIjB,QALd;AAMhB2B,MAAAA,MAAM,EAAEX,WAAW,IAAI;AANP,KAAlB;AAQEY,IAAAA,KAAK,CAACC,QAAN,CAAeC,WAAf,GAA6B,IAA7B;AACF,WAAO3C,KAAK,CAAC4C,OAAN,CAAcN,SAAd,EAAyBO,IAAzB,CACH9C,OAAO,CAACoB,cAAc,CAAC2B,WAAf,IAA8BrC,oBAA/B,CADJ,EAEHZ,SAAS,CAAEkD,MAAD,IAAY;AACpB,aAAOb,SAAS,CAACc,iBAAV,CAA4BD,MAA5B,EAAoCvC,cAApC,EAAoDyB,GAApD,CAAP;AACD,KAFQ,CAFN,EAKHtC,UAAU,CAACuC,SAAS,CAACe,UAAX,CALP,EAMHrD,GAAG,CAACuB,cAAc,CAAC+B,MAAf,IAAyBhB,SAAS,CAACiB,SAApC,CANA,CAAP;AAQC;;AAhDwB;AAoDzB,OAAO,MAAMC,SAAN,CAAgB;AAIrBC,EAAAA,WAAW,CAACC,IAAD,EAAOC,OAAP,EAAgB;AACzB,SAAKD,IAAL,GAAYA,IAAZ;AACA,SAAKC,OAAL,GAAeA,OAAf;AACD;;AAEDC,EAAAA,QAAQ,GAAG;AACT,WAAQ,cAAa,KAAKF,IAAK,IAAG,KAAKC,OAAQ,EAA/C;AACD;;AAXoB;AAcvB,OAAO,MAAMrB,SAAN,CAAgB;AAErB,SAAOiB,SAAP,CAAiBM,GAAjB,EAAsB;AACpB,QAAI,CAACA,GAAD,IAAQA,GAAG,CAAC1B,IAAJ,KAAa,IAArB,IAA6B0B,GAAG,CAAC1B,IAAJ,KAAaM,SAA9C,EAAyD;AACvD,aAAO,IAAP;AACD;;AAED,QAAIqB,YAAY,GAAG,EAAnB;;AACA,QAAI;AACFA,MAAAA,YAAY,GAAGC,MAAM,CAACC,IAAP,CAAYH,GAAG,CAAC1B,IAAhB,EAAsB,QAAtB,EAAgCyB,QAAhC,EAAf;AACD,KAFD,CAEE,OAAOK,CAAP,EAAU;AACV/C,MAAAA,MAAM,CAACgD,KAAP,CAAa,2DAAb;AACA,aAAO,IAAP;AACD;;AAED,UAAM7B,GAAG,GAAGC,SAAS,CAAC6B,aAAV,CAAwBN,GAAxB,CAAZ;;AAEA,QAAIC,YAAY,KAAK,EAAjB,IAAuBA,YAAY,KAAK,IAA5C,EAAkD;AAChD5C,MAAAA,MAAM,CAACkD,IAAP,CAAa,GAAEP,GAAG,CAACQ,MAAO,IAAGR,GAAG,CAACS,UAAW,KAAIjC,GAAI,EAApD;AACA,aAAO,IAAP;AACD;;AAED,QAAI;AACFnB,MAAAA,MAAM,CAACkD,IAAP,CAAa,GAAEP,GAAG,CAACQ,MAAO,IAAGR,GAAG,CAACS,UAAW,KAAIjC,GAAI,EAApD;AACA,aAAOkC,IAAI,CAACC,KAAL,CAAWV,YAAX,CAAP;AACD,KAHD,CAGE,OAAOG,CAAP,EAAU;AACV,YAAMQ,UAAU,GAAG;AACjBX,QAAAA,YAAY,EAAEA;AADG,OAAnB;AAIA5C,MAAAA,MAAM,CAACsB,IAAP,CAAa,GAAEH,GAAI,kDAAiDkC,IAAI,CAACG,SAAL,CAAeD,UAAf,CAA2B,EAA/F;AAEA,aAAOA,UAAP;AACD;AACF;;AAED;AACA,SAAON,aAAP,CAAqBN,GAArB,EAA0B;AACxB,QAAIxB,GAAG,GAAGwB,GAAG,CAACc,MAAJ,CAAWtC,GAArB;;AACA,QAAIwB,GAAG,CAACc,MAAJ,CAAW/B,MAAf,EAAuB;AACrB,YAAMA,MAAM,GAAGiB,GAAG,CAACc,MAAJ,CAAW/B,MAA1B;AACA,YAAMgC,SAAS,GAAGhD,MAAM,CAACiD,IAAP,CAAYjC,MAAZ,CAAlB;;AACA,UAAIgC,SAAS,CAACE,MAAV,GAAmB,CAAvB,EAA0B;AACxB,YAAI;AACF;AACAzC,UAAAA,GAAG,GAAGA,GAAG,GAAG,GAAN,GAAYuC,SAAS,CAAC5E,GAAV,CAAc+E,CAAC,IAAK,GAAEA,CAAE,IAAGC,kBAAkB,CAACpC,MAAM,CAACmC,CAAD,CAAP,CAAY,EAAzD,EAA4DE,IAA5D,CAAiE,GAAjE,CAAlB;AACD,SAHD,CAGE,OAAOhB,CAAP,EAAU;AACV/C,UAAAA,MAAM,CAACsB,IAAP,CAAa,GAAEH,GAAI,gCAAnB;AACD;AACF;AACF;;AAED,WAAOA,GAAP;AACD;;AAED,SAAOE,kBAAP,CAA0BjB,OAA1B,EAAmCsB,MAAnC,EAA2CsC,OAA3C,EAAoD;AACpD,UAAMC,IAAI,GAAGD,OAAO,IAAItF,IAAI,CAACwF,GAAL,CAASD,IAAjC;;AACA,QAAI,CAACvC,MAAD,IAAWhB,MAAM,CAACiD,IAAP,CAAYjC,MAAZ,EAAoBkC,MAApB,KAA+B,CAA9C,EAAiD;AACjD,aAAOK,IAAI,GAAG7D,OAAd;AACD;;AACD,UAAMe,GAAG,GAAG8C,IAAI,GAAG7D,OAAnB;AAEA,UAAM+D,WAAW,GAAG,EAApB;AACAzD,IAAAA,MAAM,CAACiD,IAAP,CAAYjC,MAAZ,EAAoB0C,OAApB,CAA4BC,GAAG,IAAI;AACjCF,MAAAA,WAAW,CAAC,MAAME,GAAP,CAAX,GAAyB3C,MAAM,CAAC2C,GAAD,CAA/B;AACD,KAFD;AAIA,WAAOlF,WAAW,CAACmF,UAAZ,CAAuBnD,GAAvB,EAA4BgD,WAA5B,CAAP;AACC;;AAED,SAAOjC,iBAAP,CAAyBD,MAAzB,EAAiCvC,cAAc,GAAGD,gBAAlD,EACI0B,GADJ,EACS;AACP,QAAIzB,cAAc,KAAK,IAAnB,IAA2BA,cAAc,KAAK6B,SAAlD,EAA6D;AAC7D7B,MAAAA,cAAc,GAAGhB,IAAI,CAACgB,cAAtB;AACD;;AAED,QAAI6E,KAAK,GAAG,CAAZ;AACA,WAAOtC,MAAM,CAACF,IAAP,CACH/C,SAAS,CAAE2D,GAAD,IAAS;AAEjB,UAAIA,GAAG,YAAYtD,YAAf,IAA+BkF,KAAK,GAAG1E,gCAA3C,EAA6E;AAC3EG,QAAAA,MAAM,CAACwE,KAAP,CAAa,4CAA4CrD,GAA5C,GAAkD,IAA/D,EAAqE,aAAaoD,KAAb,GAAqB,GAA1F;AAEAA,QAAAA,KAAK,IAAI,CAAT;AACA,eAAOjF,KAAK,CAACC,mBAAD,CAAZ;AACD,OALD,MAKO,IAAIgF,KAAK,IAAI7E,cAAT,IACPiD,GAAG,CAACQ,MAAJ,KAAevE,eAAe,CAAC6F,WADxB,IAEP9B,GAAG,CAACQ,MAAJ,KAAevE,eAAe,CAAC8F,YAF5B,EAGL;AACA,eAAOtF,UAAU,CAACuD,GAAD,CAAjB;AACD,OALM,MAKA;AACL3C,QAAAA,MAAM,CAACwE,KAAP,CAAa,8BAA8BrD,GAA9B,GAAoC,IAAjD,EAAuD,aAAaoD,KAAb,GAAqB,GAA5E;AAEAA,QAAAA,KAAK,IAAI,CAAT;AACA,eAAOjF,KAAK,CAACC,mBAAD,CAAZ;AACD;AACF,KAlBQ,CADN,CAAP;AAqBC;;AAED,SAAO4C,UAAP,CAAkBQ,GAAlB,EAAuB;AACrB,QAAIA,GAAG,YAAYtD,YAAnB,EAAiC;AACjC,aAAOD,UAAU,CAAC,IAAIkD,SAAJ,CAAc,GAAd,EAAmBK,GAAG,CAACF,OAAvB,CAAD,CAAjB;AACD;;AAED,QAAID,IAAI,GAAG,CAAX;AAAA,QAAcC,OAAO,GAAG,EAAxB;;AACA,QAAI;AACFD,MAAAA,IAAI,GAAGG,GAAG,CAACgC,QAAJ,CAAaxB,MAApB;AACAV,MAAAA,OAAO,GAAGE,GAAG,CAACgC,QAAJ,CAAavB,UAAvB;AACD,KAHD,CAGE,OAAOwB,GAAP,EAAY;AACZ5E,MAAAA,MAAM,CAACgD,KAAP,CAAa,qCAAb;AACD;;AAED,UAAM6B,YAAY,GAAG,CAACpC,OAAD,IAAY,CAACA,OAAO,CAACqC,WAAR,EAAb,IACjBrC,OAAO,CAACqC,WAAR,GAAsBC,QAAtB,CAA+B,IAA/B,CADJ;AAEA,UAAMC,WAAW,GAAGxC,IAAI,KAAK5D,eAAe,CAACqG,MAAzB,IAAmC,CAACzC,IAAxD;;AAEA,QAAIqC,YAAY,IAAIG,WAApB,EAAiC;AAC/BvC,MAAAA,OAAO,GAAG/D,IAAI,CAACwG,iBAAf;AACD;;AAEDlF,IAAAA,MAAM,CAACgD,KAAP,CAAa,uBAAb,EAAsCL,GAAG,CAACc,MAAJ,CAAWtC,GAAX,GAAiB,UAAvD,EAAmEqB,IAAnE,EAAyE,WAAzE,EAAsFC,OAAO,GAAG,GAAhG;AAEA,WAAOrD,UAAU,CAAC,IAAIkD,SAAJ,CAAcE,IAAd,EAAoBC,OAApB,CAAD,CAAjB;AACC;;AA5HsB","sourcesContent":["\r\nimport {conf} from '../config';\r\nimport {LoggerService} from './LoggerService';\r\nimport {HTTP_ERROR_CODE} from './HttpTypes';\r\nimport {catchError, map, retryWhen, switchMap, timeout} from 'rxjs/operators';\r\nimport Axios from 'axios-observable';\r\nimport StringUtils from './StringUtils';\r\nimport {throwError, TimeoutError, timer} from 'rxjs';\r\n\r\nconst HTTP_RETRY_INTERVAL = conf.httpRetryInterval;\r\nconst HTTP_RETRY_LIMIT = conf.httpRetryLimit;\r\nconst HTTP_REQUEST_TIMEOUT = conf.httpRequestTimeout;\r\nconst HTTP_REQUEST_TIMEOUT_RETRY_LIMIT = conf.httpRequestTimeoutRetryLimit;\r\nconst RES_TYPE = 'arraybuffer';\r\n\r\nconst logger = LoggerService.getLogger('HttpService');\r\n\r\nexport class HttpService {\r\n\r\n  static get(urlPath, requestOptions) {\r\n  return HttpService._request('get', urlPath, requestOptions);\r\n}\r\n\r\nstatic post(urlPath, requestOptions) {\r\n  return HttpService._request('post', urlPath, requestOptions);\r\n}\r\n\r\nstatic put(urlPath, requestOptions) {\r\n  return HttpService._request('put', urlPath, requestOptions);\r\n}\r\n\r\nstatic _request(method, urlPath, requestOptions) {\r\n  requestOptions = requestOptions || (Object.freeze({}));\r\n\r\nconst {useMockApi, externalUrl, pathParams, queryParams, responseType, data} = requestOptions;\r\nlet {httpRetryLimit} = requestOptions;\r\n\r\nconst mockApiBase = useMockApi ? conf.mockApiBase : '';\r\nconst url = externalUrl || HttpUtils.parseUrlWithParams(urlPath, pathParams, mockApiBase);\r\n\r\nif ((method === 'put' || method === 'post') && !requestOptions.data) {\r\n  logger.warn(`data should be provided in the requestOptions for ${method} ${url}`);\r\n}\r\n\r\nif (method === 'post' && (httpRetryLimit === null || httpRetryLimit === undefined)) {\r\n  httpRetryLimit = 0;\r\n}\r\n\r\nconst axiosOpts = {\r\n  method,\r\n  url: url,\r\n  data: data || null,\r\n  withCredentials: true,\r\n  responseType: responseType || RES_TYPE,\r\n  params: queryParams || null\r\n};\r\n  axios.defaults.crossDomain = true;\r\nreturn Axios.request(axiosOpts).pipe(\r\n    timeout(requestOptions.httpTimeout || HTTP_REQUEST_TIMEOUT),\r\n    retryWhen((errObs) => {\r\n      return HttpUtils.timedRetryHandler(errObs, httpRetryLimit, url);\r\n    }),\r\n    catchError(HttpUtils.errHandler),\r\n    map(requestOptions.parser || HttpUtils.parseJson)\r\n);\r\n}\r\n\r\n}\r\n\r\nexport class HttpError {\r\n  code;\r\n  message;\r\n\r\n  constructor(code, message) {\r\n    this.code = code;\r\n    this.message = message;\r\n  }\r\n\r\n  toString() {\r\n    return `HttpError: ${this.code} ${this.message}`;\r\n  }\r\n}\r\n\r\nexport class HttpUtils {\r\n\r\n  static parseJson(res) {\r\n    if (!res || res.data === null || res.data === undefined) {\r\n      return null;\r\n    }\r\n\r\n    let responseText = '';\r\n    try {\r\n      responseText = Buffer.from(res.data, 'binary').toString();\r\n    } catch (e) {\r\n      logger.error('Failed reading response body from server, returning null.');\r\n      return null;\r\n    }\r\n\r\n    const url = HttpUtils.rebuildReqUrl(res);\r\n\r\n    if (responseText === '' || responseText === 'OK') {\r\n      logger.info(`${res.status} ${res.statusText}: ${url}`);\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      logger.info(`${res.status} ${res.statusText}: ${url}`);\r\n      return JSON.parse(responseText);\r\n    } catch (e) {\r\n      const resTextObj = {\r\n        responseText: responseText\r\n      };\r\n\r\n      logger.warn(`${url}: Server returned text instead of JSON, using: ${JSON.stringify(resTextObj)}`);\r\n\r\n      return resTextObj;\r\n    }\r\n  };\r\n\r\n  // Axios leaves the query params out of the url, and this method recreates the full url.\r\n  static rebuildReqUrl(res) {\r\n    let url = res.config.url;\r\n    if (res.config.params) {\r\n      const params = res.config.params;\r\n      const paramKeys = Object.keys(params);\r\n      if (paramKeys.length > 0) {\r\n        try {\r\n          // build the query params back in\r\n          url = url + '?' + paramKeys.map(k => `${k}=${encodeURIComponent(params[k])}`).join('&');\r\n        } catch (e) {\r\n          logger.warn(`${url}: Failed to rebuild url string`);\r\n        }\r\n      }\r\n    }\r\n\r\n    return url;\r\n  }\r\n\r\n  static parseUrlWithParams(urlPath, params, apiBase) {\r\n  const base = apiBase || conf.api.base;\r\n  if (!params || Object.keys(params).length === 0) {\r\n  return base + urlPath;\r\n}\r\nconst url = base + urlPath;\r\n\r\nconst colonParams = {};\r\nObject.keys(params).forEach(key => {\r\n  colonParams[':' + key] = params[key];\r\n});\r\n\r\nreturn StringUtils.replaceMap(url, colonParams);\r\n}\r\n\r\nstatic timedRetryHandler(errObs, httpRetryLimit = HTTP_RETRY_LIMIT,\r\n    url) {\r\n  if (httpRetryLimit === null || httpRetryLimit === undefined) {\r\n  httpRetryLimit = conf.httpRetryLimit;\r\n}\r\n\r\nlet count = 0;\r\nreturn errObs.pipe(\r\n    switchMap((res) => {\r\n\r\n      if (res instanceof TimeoutError && count < HTTP_REQUEST_TIMEOUT_RETRY_LIMIT) {\r\n        logger.debug('Retrying request after timeout to url \"' + url + '\".', 'Attempt ' + count + '.');\r\n\r\n        count += 1;\r\n        return timer(HTTP_RETRY_INTERVAL);\r\n      } else if (count >= httpRetryLimit ||\r\n          res.status === HTTP_ERROR_CODE.BAD_REQUEST ||\r\n          res.status === HTTP_ERROR_CODE.UNAUTHORIZED\r\n      ) {\r\n        return throwError(res);\r\n      } else {\r\n        logger.debug('Retrying request to url \"' + url + '\".', 'Attempt ' + count + '.');\r\n\r\n        count += 1;\r\n        return timer(HTTP_RETRY_INTERVAL);\r\n      }\r\n    })\r\n);\r\n};\r\n\r\nstatic errHandler(res) {\r\n  if (res instanceof TimeoutError) {\r\n  return throwError(new HttpError(408, res.message));\r\n}\r\n\r\nlet code = 0, message = '';\r\ntry {\r\n  code = res.response.status;\r\n  message = res.response.statusText;\r\n} catch (err) {\r\n  logger.error('Error parsing server error message.');\r\n}\r\n\r\nconst emptyMessage = !message || !message.toLowerCase() ||\r\n    message.toLowerCase().includes('ok');\r\nconst systemError = code === HTTP_ERROR_CODE.SYSTEM || !code;\r\n\r\nif (emptyMessage || systemError) {\r\n  message = conf.defaultErrMessage;\r\n}\r\n\r\nlogger.error('Failed request to url', res.config.url + '. Status', code, '. Message', message + '.');\r\n\r\nreturn throwError(new HttpError(code, message));\r\n}\r\n}\r\n"]},"metadata":{},"sourceType":"module"}